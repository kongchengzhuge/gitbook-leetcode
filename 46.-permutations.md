# 46. Permutations

## problem description

Given a collection of **distinct** integers, return all possible permutations.

**Example:**

```text
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

## algorithm thought

得到所有排列，和之前组合数相加得到target很像。这里直接使用回溯法，加上一个位置数组，区分是否已经加入新组合。

## code

```text
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> mark(nums.size(),false);
        vector<vector<int>> res;
        vector<int> tmp;
        per(nums,res,tmp,mark);
        return res;
    }
    void per(vector<int>& nums,vector<vector<int>>& res,vector<int> tmp,vector<bool>& mark){
        if(tmp.size()==nums.size()){
            res.push_back(tmp);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(mark[i]==false){
                mark[i]=true;
                tmp.push_back(nums[i]);
                per(nums,res,tmp,mark);
                tmp.pop_back();
                mark[i]=false; 
            }
        }
    }
};
```

## algorithm thought

回溯法时间复杂度是O\(2^n\)，但是这里应该不用那么久，遍历到后期，很多数中的数组都已经被加入，只需要直接continue；所以，这个算法还是不慢的

